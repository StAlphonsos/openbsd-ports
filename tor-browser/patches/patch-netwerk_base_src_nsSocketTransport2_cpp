$OpenBSD$

diff -Nup mozilla-esr31/netwerk/base/src/nsSocketTransport2.cpp tor-browser/netwerk/base/src/nsSocketTransport2.cpp
--- netwerk/base/src/nsSocketTransport2.cpp.orig	Mon Jan  5 23:07:57 2015
+++ netwerk/base/src/nsSocketTransport2.cpp	Tue Feb 17 14:37:56 2015
@@ -812,6 +812,7 @@ nsSocketTransport::Init(const char **types, uint32_t t
     mHost = host;
 
     const char *proxyType = nullptr;
+    mProxyInfo = proxyInfo;
     if (proxyInfo) {
         mProxyPort = proxyInfo->Port();
         mProxyHost = proxyInfo->Host();
@@ -1082,6 +1083,7 @@ nsSocketTransport::BuildSocket(PRFileDesc *&fd, bool &
         const char *proxyHost  = mProxyHost.IsEmpty() ? nullptr : mProxyHost.get();
         int32_t     proxyPort  = (int32_t) mProxyPort;
         uint32_t    proxyFlags = 0;
+        nsCOMPtr<nsIProxyInfo> proxyInfo = mProxyInfo;
 
         uint32_t i;
         for (i=0; i<mTypeCount; ++i) {
@@ -1107,7 +1109,7 @@ nsSocketTransport::BuildSocket(PRFileDesc *&fd, bool &
                 // if this is the first type, we'll want the 
                 // service to allocate a new socket
                 rv = provider->NewSocket(mNetAddr.raw.family,
-                                         host, port, proxyHost, proxyPort,
+                                         host, port, proxyInfo,
                                          proxyFlags, &fd,
                                          getter_AddRefs(secinfo));
 
@@ -1121,7 +1123,7 @@ nsSocketTransport::BuildSocket(PRFileDesc *&fd, bool &
                 // so we just want the service to add itself
                 // to the stack (such as pushing an io layer)
                 rv = provider->AddToSocket(mNetAddr.raw.family,
-                                           host, port, proxyHost, proxyPort,
+                                           host, port, proxyInfo,
                                            proxyFlags, fd,
                                            getter_AddRefs(secinfo));
             }
@@ -1151,6 +1153,7 @@ nsSocketTransport::BuildSocket(PRFileDesc *&fd, bool &
                      (strcmp(mTypes[i], "socks4") == 0)) {
                 // since socks is transparent, any layers above
                 // it do not have to worry about proxy stuff
+                proxyInfo = nullptr;
                 proxyHost = nullptr;
                 proxyPort = -1;
                 proxyTransparent = true;
@@ -1793,9 +1796,25 @@ nsSocketTransport::OnSocketReady(PRFileDesc *fd, int16
         // Update poll timeout in case it was changed
         mPollTimeout = mTimeouts[TIMEOUT_READ_WRITE];
     }
-    else if (mState == STATE_CONNECTING) {
+
+//STATE_SENDINGGET: handshake proceeded to state "sent connect"
+//one more poll to OnSocketReady will trigger the get request, and state STATE_SENTGET
+//STATE_SENTGET: continue and finish handshake
+    else if (mState == STATE_SENDINGGET) {
+        if ((mPollFlags & PR_POLL_WRITE) && (outFlags & ~PR_POLL_READ)) {
+            mOutput.OnSocketReady(NS_OK);
+        }
+        mPollTimeout = mTimeouts[TIMEOUT_READ_WRITE];
+        mState = STATE_SENTGET;
+    }
+
+    else if (mState == STATE_CONNECTING || mState == STATE_SENTGET) {
         PRStatus status = PR_ConnectContinue(fd, outFlags);
-        if (status == PR_SUCCESS) {
+        if (status == PR_SUCCESS && mState == STATE_CONNECTING) {
+            OnSocketConnected();
+            mState = STATE_SENDINGGET;
+        }
+        else if (status == PR_SUCCESS && mState == STATE_SENTGET) {
             //
             // we are connected!
             //
