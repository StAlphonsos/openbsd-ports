$OpenBSD$

diff -Nup mozilla-esr31/netwerk/protocol/http/nsHttpChannel.cpp tor-browser/netwerk/protocol/http/nsHttpChannel.cpp
--- netwerk/protocol/http/nsHttpChannel.cpp.orig	Mon Jan  5 23:07:57 2015
+++ netwerk/protocol/http/nsHttpChannel.cpp	Tue Feb 17 14:37:56 2015
@@ -66,6 +66,7 @@
 #include "nsPerformance.h"
 #include "CacheObserver.h"
 #include "mozilla/Telemetry.h"
+#include "mozIThirdPartyUtil.h"
 
 namespace mozilla { namespace net {
 
@@ -1828,10 +1829,10 @@ nsHttpChannel::ResolveProxy()
     // then it is ok to use that version.
     nsCOMPtr<nsIProtocolProxyService2> pps2 = do_QueryInterface(pps);
     if (pps2) {
-        rv = pps2->AsyncResolve2(mProxyURI ? mProxyURI : mURI, mProxyResolveFlags,
+        rv = pps2->AsyncResolve2(this, mProxyResolveFlags,
                                  this, getter_AddRefs(mProxyRequest));
     } else {
-        rv = pps->AsyncResolve(mProxyURI ? mProxyURI : mURI, mProxyResolveFlags,
+        rv = pps->AsyncResolve(this, mProxyResolveFlags,
                                this, getter_AddRefs(mProxyRequest));
     }
 
@@ -2563,6 +2564,19 @@ nsHttpChannel::OpenCacheEntry(bool usingSSL)
     nsRefPtr<LoadContextInfo> info = GetLoadContextInfo(this);
     nsCOMPtr<nsICacheStorage> cacheStorage;
     nsCOMPtr<nsIURI> openURI;
+
+    /* Obtain optional third party isolation domain */
+    nsAutoCString cacheDomain;
+    nsCOMPtr<nsIURI> firstPartyIsolationURI;
+    nsCOMPtr<mozIThirdPartyUtil> thirdPartySvc
+         = do_GetService(THIRDPARTYUTIL_CONTRACTID);
+    rv = thirdPartySvc->GetFirstPartyIsolationURI(this, nullptr,
+                                           getter_AddRefs(firstPartyIsolationURI));
+    if (NS_SUCCEEDED(rv) && firstPartyIsolationURI) {
+        thirdPartySvc->GetFirstPartyHostForIsolation(firstPartyIsolationURI,
+                cacheDomain);
+    }
+
     if (!mFallbackKey.IsEmpty() && mFallbackChannel) {
         // This is a fallback channel, open fallback URI instead
         rv = NS_NewURI(getter_AddRefs(openURI), mFallbackKey);
@@ -2617,7 +2631,7 @@ nsHttpChannel::OpenCacheEntry(bool usingSSL)
         cacheEntryOpenFlags |= nsICacheStorage::OPEN_BYPASS_IF_BUSY;
 
     rv = cacheStorage->AsyncOpenURI(
-        openURI, mPostID ? nsPrintfCString("%d", mPostID) : EmptyCString(),
+        openURI, nsPrintfCString("%s@%d", cacheDomain.get(), mPostID),
         cacheEntryOpenFlags, this);
     NS_ENSURE_SUCCESS(rv, rv);
 
@@ -2652,7 +2666,7 @@ bypassCacheEntryOpen:
     NS_ENSURE_SUCCESS(rv, rv);
 
     rv = cacheStorage->AsyncOpenURI(
-      mURI, EmptyCString(), nsICacheStorage::OPEN_TRUNCATE, this);
+      mURI, cacheDomain, nsICacheStorage::OPEN_TRUNCATE, this);
     NS_ENSURE_SUCCESS(rv, rv);
 
     waitFlags.Keep(WAIT_FOR_OFFLINE_CACHE_ENTRY);
@@ -3257,6 +3271,12 @@ nsHttpChannel::AssembleCacheKey(const char *spec, uint
         cacheKey.Append(buf);
     }
 
+    if (strlen(mCacheDomain.get()) > 0) {
+        cacheKey.AppendLiteral("domain=");
+        cacheKey.Append(mCacheDomain.get());
+        cacheKey.AppendLiteral("&");
+    }
+
     if (!cacheKey.IsEmpty()) {
         cacheKey.AppendLiteral("uri=");
     }
@@ -4580,6 +4600,8 @@ nsHttpChannel::BeginConnect()
     // notify "http-on-modify-request" observers
     CallOnModifyRequestObservers();
 
+    RemoveAuthorizationHeaderIfAppropriate();
+
     // Check to see if we should redirect this channel elsewhere by
     // nsIHttpChannel.redirectTo API request
     if (mAPIRedirectToURI) {
@@ -4706,7 +4728,7 @@ nsHttpChannel::SetPriority(int32_t value)
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
-nsHttpChannel::OnProxyAvailable(nsICancelable *request, nsIURI *uri,
+nsHttpChannel::OnProxyAvailable(nsICancelable *request, nsIChannel *channel,
                                 nsIProxyInfo *pi, nsresult status)
 {
     LOG(("nsHttpChannel::OnProxyAvailable [this=%p pi=%p status=%x mStatus=%x]\n",
@@ -5541,6 +5563,23 @@ nsHttpChannel::SetCacheTokenCachedCharset(const nsACSt
                                            PromiseFlatCString(aCharset).get());
 }
 
+
+NS_IMETHODIMP
+nsHttpChannel::GetCacheDomain(nsACString &value)
+{
+    value = mCacheDomain;
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsHttpChannel::SetCacheDomain(const nsACString &value)
+{
+    mCacheDomain = value;
+
+    return NS_OK;
+}
+
 //-----------------------------------------------------------------------------
 // nsHttpChannel::nsICachingChannel
 //-----------------------------------------------------------------------------
@@ -5713,6 +5752,72 @@ nsHttpChannel::ResumeAt(uint64_t aStartPos,
     return NS_OK;
 }
 
+// Remove the Authorization header if first party isolation is active and
+// this channel is processing a third party request. This prevents user
+// tracking via HTTP Basic Authentication.
+// Note that this approach disables authentication for 3rd party domains. It
+// would be better if we could isolate the authentication while still allowing
+// it to be transmitted... but HTTP authentication is rarely used anyway.
+void
+nsHttpChannel::RemoveAuthorizationHeaderIfAppropriate()
+{
+    if (!mRequestHead.PeekHeader(nsHttp::Authorization)) {
+        return; // No Authorization header is present.
+    }
+
+    nsCOMPtr<mozIThirdPartyUtil> thirdPartySvc
+                                = do_GetService(THIRDPARTYUTIL_CONTRACTID);
+    bool isolationActive = true;
+    (void)thirdPartySvc->IsFirstPartyIsolationActive(this, nullptr,
+                                                     &isolationActive);
+    if (!isolationActive)
+        return; // First party isolation is disabled for this channel.
+
+    bool isAuthAllowed = false;
+    nsCOMPtr<nsIURI> firstPartyURI;
+    nsresult rv = thirdPartySvc->GetFirstPartyURIFromChannel(this, false,
+                                               getter_AddRefs(firstPartyURI));
+    if (NS_SUCCEEDED(rv) && firstPartyURI) {
+        isAuthAllowed = (mURI == firstPartyURI)
+                        || HostPartIsTheSame(firstPartyURI);
+    } else {
+        // We failed to get the first party URI. Check the document URI so
+        // that we can allow authentication if the request originates from the
+        // the browser chrome, e.g., some favicon requests. If there is no
+        // document URI associated with this request, it cannot be associated
+        // with a content document, so it must be a special request (e.g.,
+        // favicon fetch or OSCP), for which we also allow authenication.
+        nsCOMPtr<nsIURI> docURI;
+        rv = GetDocumentURI(getter_AddRefs(docURI));
+        if (NS_FAILED(rv) || !docURI) {
+            isAuthAllowed = true;
+        } else {
+            nsAutoCString docURISpec;
+            docURI->GetAsciiSpec(docURISpec);
+            if (docURISpec == "chrome://browser/content/browser.xul")
+                isAuthAllowed = true;
+        }
+    }
+
+    if (!isAuthAllowed) {
+        mRequestHead.ClearHeader(nsHttp::Authorization);
+        mRequestHead.ClearHeader(nsHttp::Cache_Control);
+        mRequestHead.ClearHeader(nsHttp::Pragma);
+
+#ifdef PR_LOGGING
+        nsAutoCString requestURIStr, firstPartyURIStr;
+        mURI->GetAsciiSpec(requestURIStr);
+        if (firstPartyURI)
+            firstPartyURI->GetAsciiSpec(firstPartyURIStr);
+        else
+            firstPartyURIStr = "--N/A--";
+        LOG(("Removed Authorization header from third party request"
+              " [Request URI=%s, First Party URI=%s]\n",
+              requestURIStr.get(), firstPartyURIStr.get()));
+#endif
+    }
+}
+
 nsresult
 nsHttpChannel::DoAuthRetry(nsAHttpConnection *conn)
 {
@@ -5733,6 +5838,8 @@ nsHttpChannel::DoAuthRetry(nsAHttpConnection *conn)
 
     // notify "http-on-modify-request" observers
     CallOnModifyRequestObservers();
+
+    RemoveAuthorizationHeaderIfAppropriate();
 
     mIsPending = true;
 
