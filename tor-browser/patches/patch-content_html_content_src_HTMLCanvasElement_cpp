$OpenBSD$

diff -Nup mozilla-esr31/content/html/content/src/HTMLCanvasElement.cpp tor-browser/content/html/content/src/HTMLCanvasElement.cpp
--- content/html/content/src/HTMLCanvasElement.cpp.orig	Mon Jan  5 23:08:00 2015
+++ content/html/content/src/HTMLCanvasElement.cpp	Tue Feb 17 14:37:55 2015
@@ -31,6 +31,7 @@
 #include "nsMathUtils.h"
 #include "nsNetUtil.h"
 #include "nsStreamUtils.h"
+#include "CanvasUtils.h"
 #include "ActiveLayerTracker.h"
 
 #ifdef MOZ_WEBGL
@@ -348,7 +349,7 @@ HTMLCanvasElement::MozFetchAsStream(nsIInputStreamCall
   nsCOMPtr<nsIInputStream> inputData;
 
   nsAutoString type(aType);
-  rv = ExtractData(type, EmptyString(), getter_AddRefs(inputData));
+  rv = ExtractData(nsContentUtils::GetCurrentJSContext(), type, EmptyString(), getter_AddRefs(inputData));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIAsyncInputStream> asyncData = do_QueryInterface(inputData, &rv);
@@ -380,13 +381,18 @@ HTMLCanvasElement::GetMozPrintCallback() const
 }
 
 nsresult
-HTMLCanvasElement::ExtractData(nsAString& aType,
+HTMLCanvasElement::ExtractData(JSContext* aCx,
+                               nsAString& aType,
                                const nsAString& aOptions,
                                nsIInputStream** aStream)
 {
+  // Check site-speciifc permission and display prompt if appropriate.
+  // If no permission, return all-white, opaque image data.
+  bool usePlaceholder = !CanvasUtils::IsImageExtractionAllowed(OwnerDoc(), aCx);
   return ImageEncoder::ExtractData(aType,
                                    aOptions,
                                    GetSize(),
+                                   usePlaceholder,
                                    mCurrentContext,
                                    aStream);
 }
@@ -459,12 +465,12 @@ HTMLCanvasElement::ToDataURLImpl(JSContext* aCx,
   }
 
   nsCOMPtr<nsIInputStream> stream;
-  rv = ExtractData(type, params, getter_AddRefs(stream));
+  rv = ExtractData(aCx, type, params, getter_AddRefs(stream));
 
   // If there are unrecognized custom parse options, we should fall back to
   // the default values for the encoder without any options at all.
   if (rv == NS_ERROR_INVALID_ARG && usingCustomParseOptions) {
-    rv = ExtractData(type, EmptyString(), getter_AddRefs(stream));
+    rv = ExtractData(aCx, type, EmptyString(), getter_AddRefs(stream));
   }
 
   NS_ENSURE_SUCCESS(rv, rv);
@@ -522,9 +528,13 @@ HTMLCanvasElement::ToBlob(JSContext* aCx,
   nsCOMPtr<nsIScriptContext> scriptContext =
     GetScriptContextFromJSContext(nsContentUtils::GetCurrentJSContext());
 
+  // Check site-specific permission and display prompt if appropriate.
+  // If no permission, return all-white, opaque image data.
+  bool usePlaceholder = !CanvasUtils::IsImageExtractionAllowed(OwnerDoc(), aCx);
+
   uint8_t* imageBuffer = nullptr;
   int32_t format = 0;
-  if (mCurrentContext) {
+  if (mCurrentContext && !usePlaceholder) {
     mCurrentContext->GetImageBuffer(&imageBuffer, &format);
   }
 
@@ -534,7 +544,8 @@ HTMLCanvasElement::ToBlob(JSContext* aCx,
                                        imageBuffer,
                                        format,
                                        GetSize(),
-                                       mCurrentContext,
+                                       usePlaceholder,
+                                       mCurrentContext, // ignored
                                        scriptContext,
                                        aCallback);
 }
@@ -572,7 +583,8 @@ HTMLCanvasElement::MozGetAsFileImpl(const nsAString& a
 {
   nsCOMPtr<nsIInputStream> stream;
   nsAutoString type(aType);
-  nsresult rv = ExtractData(type, EmptyString(), getter_AddRefs(stream));
+  nsresult rv = ExtractData(nsContentUtils::GetCurrentJSContext(),
+                            type, EmptyString(), getter_AddRefs(stream));
   NS_ENSURE_SUCCESS(rv, rv);
 
   uint64_t imgSize;
